"""
(1)
Procedural programming focuses on how programs are executed in a certain sequence, like beginning from
top to bottom. This also includes control structures, who can make it so that codes are not necessarily
executed from top to bottom. Functional programming focuses on how to make the program solve a 
certain problem or how to make the program useful for our purposes, particularly by making 
use of functions.

In programming, you should have a good grasp on both so you can easily make codes without having to run
and run them just to know what the problem is.
"""

"""
(2)
Git is somewhat like the Google Docs for programmers and coders 
in the sense that it allows for online, remote collaboration. 
It allows users to share codes without needing to pass files through traditional channels
like email, or USB. Additionally, it also has many useful features aside from code sharing
that make collaboration easier, such as commit messages, which tell the users who have access to the
codes in the repository what has been changed and when those changes were made. This way, users
don't have to work together in real-time and face to face to build their codes.

Version control is also another valuable feature Git has. It's kind of like quarantine, in the sense
that coders can 'isolate' a part of the code they are working on to avoid 'infecting' the rest
of the code in case something goes wrong. It does this by making 'branches' of code which can be
appropriately set apart or built upon as needed.
"""

"""
(3)
In general, the main difference between a for loop and a while loop is 
whether you know how many iterations you need or not. A for loop is used when you want a section
of code to repeat over a number of items in a given sequence, while a while loop is used when you
want a section of code to repeat until a given value is false.

An example of a real life 'for loop' is as follows:
I am doing a closed-loop traverse around the Sunken Garden. After doing a quick recon,
I have decided that I will set up 4 traverse stations. I know that for each traverse station,
I will have to do the following:
    - set up the total station
    - get the becksight
    - get the foresight
    - ligpit the total station
    - move on to the next traverse station

Since I have 4 traverse stations, I will have to do that sequence of procedures 4 times for each
station in the closed loop (excluding the setup at CP1).

Meanwhile, an example of a real life 'while loop' would be something like this:
I am a GE120 student and I have to pass my machine exercise. While my code is not producing the 
desired output I will have to do the following:
    - search for the problematic part of the code
    - understand why it is problematic
    - fix the problem
    - run the code again

Until my code produces the desired output, I will have to do those steps over and over again.
The key difference here is that I don't know how many times I will have to repeat this sequence,
I only know that I have to keep doing it until I get the result I want; while in my earlier example
I know that I will only have to do the procedures 4 times, once for every station in my loop.
"""

"""
(4)
The 'divide and conquer' strategy in programming says that you have to divide a big problem into
smaller problems which are more easily solved or conquered. Seeing as individual codes make up
one program built to execute specific functions, it is no wonder why the divide and conquer strategy
is the way to go. When coding, one should go step by step, being careful to translate pseudocodes into
machine language. You should always make sure that each step is done correctly, because the next one
will always build upon it. Similar to a war, battles must be won in order to declare victory.
Otherwise, a small mistake in an earlier step could cause your whole code to function not as intended,
and it will be harder for you to rectify those errors after the fact since you have so much code to
debug as compared to just a few short lines.
"""

"""
(5)
Most survey calculations are what I would call "semi-automatic", where although many surveyors use Excel
or other similar applications for the survey computations, it still requires effort on the part of the
surveyor to configure the spreadsheet for their calculations. They still have to input formulas and other
needed information. With programming, you can make the process fully automatic, where the user just inputs
the expected data and the results are entirely done by the program. This code can then be turned into a
website where other surveyors can use the code for their own surveys or to cross-check their results.

I would use my knowledge of python to turn these equations into the program I described by chunking the
whole operation into individual parts. For example, a simple subdivision calulator. It would involve
getting the technical description of the lot, then getting the area of the lot, and so on and so forth,
following all the steps as described in GE 10. The user would only need to input the technical description
and how the lot should be divided.

"""
